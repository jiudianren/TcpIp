https://blog.csdn.net/freeking101/article/details/78922846

#什么是半连接和半关闭？

半连接是指已经建立好的连接的一端已经关闭或异常终止，而另一端却不知道（依然显示连接ESTABLISHED）的状况；
半关闭是指已建立连接的一端执行半关闭，终止某个方向的数据传送，这时连接处于半关闭状态（主动关闭端FIN_WAIT_2，另一端CLOSE_WAIT）。

# 什么是长链接 什么是短链接 各适用什么场景
长短连接只是一个概念问题，长短连接的socket都是使用普通的socket函数，没有什么特殊的。

##长连接 
是客户和服务器建立连接后不断开，持续用这个连接通信，持续过程中一般需要连接侦测，客户探测服务，或者服务心跳告知客户，应用层的保活机制。



长连接过程：连接(只建立一次连接)-> 传输数据 -> 保持连接 -> ......->?传输数据 -> 保持连接?-> 关闭连接(只有一次关闭)。
 长连接指建立SOCKET连接后不管是否使用都保持连接，但安全性较差。
 其实长连接是相对于通常的短连接而说的，也就是长时间保持客户端与服务端的连接状态。这就要求长连接在没有数据通信时，定时发送数据包，以维持连接状态，这就是心跳机制。短连接在没有数据传输时直接关闭就行了。

场景：比如你请求了CSDN的一个网页，这个网页里肯定还包含了CSS、JS等等一系列资源，如果你是短连接（也就是每次都要重新建立TCP连接）的话，那你每打开一个网页，基本要建立几个甚至几十个TCP连接，这就浪费了很多资源。但如果是长连接的话，那么这么多次HTTP请求（这些请求包括请求网页内容，CSS文件，JS文件，图片等等），其实使用的都是一个TCP连接，很显然是可以节省很多资源。最后关于长连接还要多提一句，那就是，长连接并不是永久连接的。如果一段时间内（具体的时间长短，是可以在header当中进行设置的，也就是所谓的超时时间），这个连接没有HTTP请求发出的话，那么这个长连接就会被断掉。这一点其实很容易理解，否则的话，TCP连接将会越来越多，直到把服务器的TCP连接数量撑爆到上限为止。现在想想，对于服务器来说，服务器里的这些个长连接其实很有数据库连接池的味道，都是为了节省连接并重复利用。




## 短连接
是通信一次后就关闭连接。长短连接是一种通信约定，需要双方一起遵守。比如在长连接时，两端都不close，客户端/服务端协议保活；短连接时两端都要主动或被动close，以完成四路释放。

HTTP是无状态的，浏览器和服务器每进行一次HTTP操作，就建立一次连接，但任务结束就中断连接.HTTP协议是基于请求/响应模式的，因此只要服务端给了响应，本次HTTP连接就结束了。或者更准确的说，是本次HTTP请求就结束了，根本没有长连接这一说。那么自然也就没有短连接这一说了。之所以说HTTP分为长连接和短连接，其实本质上是说的TCP连接。TCP连接是一个双向的通道，它是可以保持一段时间不关闭的，因此TCP连接才有真正的长连接和短连接这一说.

## 长连接与短连接的使用时机

长连接多用于操作频繁，点对点的通讯，而且连接数不能太多的情况。

每个TCP连接的建立都需要三次握手，每个TCP连接的断开要四次握手。如果每次操作都要建立连接然后再操作的话处理速度会降低，所以每次操作下次操作时直接发送数据就可以了，不用再建立TCP连接。例如：数据库的连接用长连接，如果用短连接频繁的通信会造成socket错误，频繁的socket创建也是对资源的浪费。  



短连接：web网站的http服务一般都用短连接。因为长连接对于服务器来说要耗费一定的资源。像web网站这么频繁的成千上万甚至上亿客户端的连接用短连接更省一些资源。试想如果都用长连接，而且同时用成千上万的用户，每个用户都占有一个连接的话，可想而知服务器的压力有多大。所以并发量大，但是每个用户又不需频繁操作的情况下需要短连接。  
总之：长连接和短连接的选择要视需求而定  

##长连接的心跳机制  
 通讯实体间使用长连接时，一般还需要定义心跳消息，定期发送来检测系统间链路是否异常，每隔一定时间发送一次心跳，如果一定次数没有收到心跳消息，这认为此连接出现问题，需要断开连接重新建立。  
 具体心跳消息的格式，以及发送间隔，以 及多少次没有收到心跳就认为链路异常，以及数据部是否算作心跳消息（有的系统如果接收到数据包则会清除心跳计时器也就相当于系统中的数据包也算作心跳消息）；这个需要两端进行协商。比如GSM常用的短消息中心和其他网络实体互连的SMPP协议，要求建立的就是长连接

 心跳包之所以叫心跳包是因为：它像心跳一样每隔固定时间发一次，以此来告诉服务器，这个客户端还活着。事实上这是为了保持长连接，至于这个包的内容，是没有什么特别规定的，不过一般都是很小的包，或者只包含包头的一个空包。



    在TCP的机制里面，本身是存在有心跳包的机制的，也就是TCP的选项：SO_KEEPALIVE。
    
系统默认是设置的2小时的心跳频率。但是它检查不到机器断电、网线拔出、防火墙这些断线。而且逻辑层处理断线可能也不是那么好处理。一般，如果只是用于保活还是可以的  
 心跳包一般来说都是在逻辑层发送空的echo包来实现的。下一个定时器，在一定时间间隔下发送一个空包给客户端，然后客户端反馈一个同样的空包回来，服务器如果在一定时间内收不到客户端发送过来的反馈包，那就只有认定说掉线了。  
   其实，要判定掉线，只需要send或者recv一下，如果结果为零，则为掉线。但是，在长连接下，有可能很长一段时间都没有数据往来。理论上说，这个连接是一直保持连接的，但是实际情况中，如果中间节点出现什么故障是难以知道的。更要命的是，有的节点（防火墙）会自动把一定时间之内没有数据交互的连接给断掉。在这个时候，就需要我们的心跳包了，用于维持长连接，保活。
 在获知了断线之后，服务器逻辑可能需要做一些事情，比如断线后的数据清理呀，重新连接呀……当然，这个自然是要由逻辑层根据需求去做了。

#### TCP的socket本身就是长连接，为什么还需要心跳包?

1.  内网机器如果不主动向外发起连接，外网机没法直接连接内网的，这也是内网机安全的原因之一，又因为路由器会把这个关系记录下来，但是过一段时间这个纪录可能会丢失，所以每一个客户端每个一定时间就会向服务器发送消息，以确保服务器可以随时找到你，这个东西被称为心跳包。


2. 理论上说，这个连接事一直保持连接的，但实际情况中，如果中间出现什么情况是难以想象的。更要命的是，有的节点（防火墙）会自动把一定时间之内没有数据交互的连接给断掉。这个时候我们就需要心跳包了，用于维持长连接，保活。

总之：心跳包主要也就是用于长连接的保活和断线处理。一般的应用下，判定时间在30-40秒比较不错。如果实在要求高，那就在6-9秒。在TCPsocket心跳机制中，心跳包可以由服务器发送给客户端，也可以由客户端发送给服务器，不过比较起来，前者开销可能更大。

一个由客户端给服务器发送心跳包，基本思路是：

1. 服务器为每个客户端保存了IP和计数器count，即map<fd,pair<ip, count>>。
 	服务端主线程采用 select 实现多路IO复用监听新连接以及接受数据包（心跳包），子线程用于检测心跳：
   如果主线程接收到的是心跳包，将该客户端对应的计数器 count 清零；
 		在子线程中，每隔3秒遍历一次所有客户端的计数器 count： 
 		若 count 小于 5，将 count 计数器加 1；
 		若 count 等于 5，说明已经15秒未收到该用户心跳包，判定该用户已经掉线；
 		
2.  客户端则只是开辟子线程，定时给服务器发送心跳包（本示例中定时时间为3秒）。

# 保护消息边界和流
保护消息边界，就是指传输协议把数据当作一条独立的消息在网上传输，接收端只能接收独立的消息。也就是说存在保护消息边界，接收端一次只能接收发送端发出的一个数据包。而面向流则是指无保护消息保护边界的，如果发送端连续发送数据，接收端有可能在一次接收动作中，会接收两个或者更多的数据包。

例如，我们连续发送三个数据包，大小分别是2k，4k ，8k,这三个数据包，都已经到达了接收端的网络堆栈中，如果使用UDP协议，不管我们使用多大的接收缓冲区去接收数据，我们必须有三次接收动作，才能够把所有的数据包接收完.而使用TCP协议，我们只要把接收的缓冲区大小设置在14k以上，我们就能够一次把所有的数据包接收下来，只需要有一次接收动作。 
注意：这就是因为UDP协议的保护消息边界使得每一个消息都是独立的。而流传输却把数据当作一串数据流，他不认为数据是一个一个的消息。所以有很多人在使用tcp协议通讯的时候，并不清楚tcp是基于流的传输，当连续发送数据的时候，他们时常会认识tcp会丢包。

其实不然，因为当他们使用的缓冲区足够大时，他们有可能会一次接收到两个甚至更多的数据包，而很多人往往会忽视这一点，只解析检查了第一个数据包，而已经接收的其他数据包却被忽略了。所以大家如果要作这类的网络编程的时候,必须要注意这一点。



# Client 和 Server 通信发送与接收方式设计

在长连接中一般是没有条件能够判断读写什么时候结束，所以必须要加长度报文头。读函数先是读取报文头的长度，再根据这个长度去读相应长度的报文。
在通信数据发送与接收之间也存在不同的方式，即同步和异步两种方式。这里的同步和异步与 I/O 层次的同异步概念不同。主要涉及 socket APIs recv() 和
 send() 的不同组合方式。

同步发送与接收
从应用程序设计的角度讲，报文发送和接收是同步进行的，既报文发送后，发送方等待接收方返回消息报文。同步方式一般需要考虑超时问题，即报文发出去后发送 方不能无限等待，需要设定超时时间，超过该时间后发送方不再处于等待状态中，而直接被通知超时返回。同步发送与接收经常与短连接通信方式结合使用，称为同
 步短连接通信方式，其 socket 事件流程可如上面的图 １２ 所示。

异步发送与接收
从应用程序设计的角度讲，发送方只管发送数据，不需要等待接收任何返回数据，而接收方只管接收数据，这就是应用层的异步发送与接收方式。要实现异步方式， 通常情况下报文发送和接收是用两个不同的进程来分别处理的，即发送与接收是分开的，相互独立的，互不影响。异步发送与接收经常与长连接通信方式结合使用，
 称为异步长连接通信方式。从应用逻辑角度讲，这种方式又可分双工和单工两种情况。

异步双工
异步双工是指应用通信的接收和发送在同一个程序中，而有两个不同的子进程分别负责发送和接收，异步双工模式是比较复杂的一种通信方式，有时候经常会出现在 不同机构之间的两套系统之间的通信。比如银行与银行之间的信息交流。它也可以适用在现代
 P2P 程序中。如图 １４ 所示，Server 和 Client 端分别 fork 出两个子进程，形成两对子进程之间的连接，两个连接都是单向的，一个连接是用于发送，另一个连接用于接收，这样方式的连接就被称为异步双工方式连接。
长连接异步双工模式

异步单工应用通信的接收和发送是用两个不同的程序来完成，这种异步是利用两对不同程序依靠应用逻辑来实现的。下面图显示了长连接方式下的异步单工模式，在通信的 A 和 B 端，分别有两套 Server 和 Client 程序，B 端的 Client 连接 A 端的 Server，A 端的 Server 只负责接收 B 端 Client 发送的报文。A 端的 Client 连接 B 端的 Server，A 端 Client 只负责向 B 端 Server 发送报文。

# 什么是黏包 ，如何解决黏包

之所以出现粘包和半包现象,是因为TCP当中，只有流的概念，没有包的概念。
TCP是一种流协议（stream protocol）。这就意味着数据是以字节流的形式传递给接收者的，没有固有的"报文"或"报文边界"的概念。从这方面来说，读取TCP数据就像从串行端口读取数据一样--无法预先得知在一次指定的读调用中会返回多少字节（也就是说能知道总共要读多少，但是不知道具体某一次读多少 .



##半包
指接受方没有接受到一个完整的包，只接受了部分，这种情况主要是由于TCP为提高传输效率，将一个包分配的足够大，导致接受方并不能一次接受完。（?在长连接和短连接中都会出现）。

##粘包与分包
指发送方发送的若干个包数据到接收方接收时粘成一个完整的包数据，从接收缓冲区看，后一包数据的头紧接着前一包数据的尾。如下图：客户端同一时间发送几条数据，而服务端只能收到一大条数据，

由于传输的过程为数据流，经过TCP 传输后，三条数据被合并成了一条，这就是数据粘包了。
出现粘包现象的原因是多方面的，它既可能由发送方造成，也可能由接收方造成。
#### 发送方 
发送方引起的粘包是由TCP协议本身造成的，TCP为提高传输效率，发送方往往要收集到足够多的数据后才发送一包数据。若连续几次发送的数据都很少，通常TCP会根据优化算法把这些数据合成一包后一次发送出去，这样接收方就收到了粘包数据。这么做优点也很明显，就是为了减少广域网的小分组数目，从而减小网络拥塞的出现。总的来说就是：发送端发送了几次数据，接收端一次性读取了所有数据，造成多次发送一次读取；通常是网络流量优化，把多个小的数据段集满达到一定的数据量，从而减少网络链路中的传输次数。
#### 接收方
 接收方引起的粘包是由于接收方用户进程不及时接收数据，从而导致粘包现象。这是因为接收方先把收到的数据放在系统接收缓冲区，用户进程从该缓冲区取数据，若下一包数据到达时前一包数据尚未被用户进程取走，则下一包数据放到系统接收缓冲区时就接到前一包数据之后，而用户进程根据预先设定的缓冲区大小从系统接收缓冲区取数据，这样就一次取到了多包数据。分包是指在出现粘包的时候我们的接收方要进行分包处理。（在长连接中都会出现）。总的来说就是：发送端发送了数量比较多的数据，接收端读取数据时候数据分批到达，造成一次发送多次读取；通常和网络路由的缓存大小有关系，一个数据段大小超过缓存大小，那么就要拆包发送。

tcp粘包、半包的处理方式：
1.一是采用分隔符的方式，采用特殊的分隔符作为一个数据包的结尾；

2. 二是采用给每个包的特定位置（如包头两个字节）加上数据包的长度信息，另一端收到数据后根据数据包的长度截取特定长度的数据解析，假设包头信息的数据长度为infoLen，接收到的数据包真实长度为trueLen，那么有如下几种情况：
1： infoLen>trueLen，半包。
2： infoLen<trueLen，粘包。
3： infoLen=trueLen，正常。


#断包
UDP 就不会有上面这种情况，它不会使用块的合并优化算法。当然除了优化算法，TCP 和 UDP 都会因为下面两种情况造成粘包：断包
? ? ? ? 断包比较好理解的，比如我们发送一条很大的数据包，类似图片和录音等等，很显然一次发送或者读取数据的缓冲区大小是有限的，所以我们会分段去发送或者读取数据。

无论是粘包还是断包，如果我们要正确解析数据，那么必须要使用一种合理的机制去解包。
这个机制的思路其实很简单：我们在封包的时候给每个数据包加一个长度或者一个开始结束标记。然后我们拆包的时候就能区分每个数据包了，再按照长度或者分解符去分拆成各个数据包。


