https://blog.csdn.net/liujiyong7/article/details/43346829


http://baijiahao.baidu.com/s?id=1602711545796607411&wfr=spider&for=pc


C10K 和 C1000K 回顾



在LIUX2.2.6内核版本之前，在LIUX2.2.6内核内核版本中接受调用之前的系统API，当多个线程中的接受函数同时侦听同一个ListNFD时，如果ListEnfd变得可读，使用接受函数的所有线程（或进程）都等待Li。Sttfd将被唤醒，但最终只有一个线程能够成功地返回PT调用，另一个线程的接受函数调用返回ErError错误，线程返回到等待状态，这是接受函数生成的惊群问题。然而，在LIUX2.6版本之后，内核解决了接受函数的问题，当内核接收到连接时，它只唤醒等待队列上的第一个线程（或进程），从而避免了惊群问题。
EPOLL函数中的惊群问题，如果我们使用多线程EPOLL监视同一个FD，当FD事件到达时，内核唤醒所有的EPOLL线程，从而导致一个惊群问题。为什么内核不能解决像接受问题那样的EPOLL问题？内核可以解决调用中的Access问题，因为内核清楚地知道接受调用对于单个线程来说是可能成功的，并且其他线程必须失败。对于EPOLL调用，内核不知道究竟需要多少线程来处理该事件，因此只能唤醒所有线程。
在实际应用程序开发过程中线程池中的惊群问题，为了避免频繁创建和销毁线程，我们通常创建线程池来处理并发，并且线程池最经典的模型是生产者-消费者模型。NS是一个任务队列，当队列不是空的时候，线程池中的线程将任务从任务队列中取出来处理它。通常使用条件变量进行处理，当我们把一个任务在任务队列，我们需要唤醒等待的线程处理的任务，如果我们使用的功能notify_all（）在C++标准库来唤醒线程的所有线程都会醒来，然后最终只有一个AD可以获得任务的处理能力。其他线程在这里睡着，从而创建一个惊群问题。

