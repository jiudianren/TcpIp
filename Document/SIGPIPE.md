
参考 《unix网络编程 5.12  5.13》
1、SIGPIPE

产生原因：

TCP的"四次分手"关闭. TCP是全双工的信道,?可以看作两条单工信道, 
TCP连接两端的两个端点各负责一条.?当对端调用close时,本端只是收到FIN包.按照TCP协议的语义,表示对端只是关闭了其所负责的那一条单工信道。
也就是说,?因为TCP协议的限制,?一个端点无法获知对端的socket是调用了close还是shutdown。

对一个已经收到FIN包的socket调用read方法,?如果接收缓冲已空,?则返回0,?这就是常说的表示连接关闭.?

但第一次对其调用write方法时,如果发送缓冲没问题,会返回正确写入(发送).  
但发送的报文会导致对端发送RST报文,?因为对端的socket已经调用了close,?完全关闭,  
既不发送,?也不接收数据.?
所以,第二次调用write方法(假设在收到RST之后), 会生成SIGPIPE信号,?导致进程退出。

#场景：
客户端和服务器建立连接以后，正常通讯，
这时候，kill掉通讯子进程， 服务器发送 FIN。客户端接受到FIN,只是标志，不能再从服务端读取数据。这时候调用read方法，如果接受缓冲区已经空了，则返回0，表示对端的发关闭。

但客户端仍然能够像服务端调用writ，继续发送消息（第一次）。但是服务端，已经关闭了该连接，当服务端接受到客户端这是发送来的第一个数据的时候，会相应一个RST。
如果客户端不处理该RST,或者客户端处理该RST, 但仍然 继续在此socket上发送消息（第二次），则客户端主机内核像客户端进程发送一个SIGPIPE，信号。

# 该信号，默认行为是终止进程。因此进程必须捕获它并进行处理


# 《APUE》中解释 SIGPIPE 产生的原因 “写至无读进程的管道”



